package egm.io.nifi.processors.ckan.utils;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
import egm.io.nifi.processors.ckan.ngsild.Attributes;
import egm.io.nifi.processors.ckan.ngsild.Entity;
import egm.io.nifi.processors.ckan.ngsild.NGSICharsets;
import egm.io.nifi.processors.ckan.ngsild.NGSIConstants;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Class for aggregating batches in column mode.
 */
public class CKANColumnAggregator {

    private final Map<String, JsonElement> aggregation = new LinkedHashMap<>();

    /**
     * Linked hash map without default fields linked hash map.
     *
     * @return the linked hash map without metadata objects (if attrMetadataStore is set to true)
     *  also removes "_type" and "RECV_TIME_TSC" keys from the object
     */
    private Map<String, JsonElement> aggregationWithoutDefaultFields() {
        return aggregation.entrySet().stream().filter(entry ->
            !entry.getKey().contains(NGSIConstants.AUTOGENERATED_ATTR_TYPE) &&
                !entry.getKey().equals(NGSIConstants.RECV_TIME_TS + "C")
        ).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    public List<JsonObject> toJsonObjects() {
        return aggregationWithoutDefaultFields().entrySet().stream().map(entry -> {
            JsonObject jsonObject = new JsonObject();
            jsonObject.add(entry.getKey(), entry.getValue());
            return jsonObject;
        }).collect(Collectors.toList());
    }

    public void initialize(Entity entity, long creationTime, String datasetIdPrefixToTruncate) {
        String recvTime = CommonConstants.getHumanReadable(creationTime, true);

        aggregation.put(NGSIConstants.RECV_TIME, new JsonPrimitive(recvTime));
        aggregation.put(NGSIConstants.ENTITY_ID, new JsonPrimitive(entity.getEntityId()));
        aggregation.put(NGSIConstants.ENTITY_TYPE, new JsonPrimitive(entity.getEntityType()));

        ArrayList<Attributes> attributes = entity.getEntityAttrs();
        if (attributes == null || attributes.isEmpty()) {
            return;
        }

        aggregateAttributeValues("", attributes, datasetIdPrefixToTruncate);
    }

    public void aggregateAttributeValues(
            String attributePrefix,
            ArrayList<Attributes> attributes,
            String datasetIdPrefixToTruncate
    ) {
        for (Attributes attribute : attributes) {
            String encodedAttrName = encodeAttributeName(attribute.getAttrName(), attribute.getDatasetId(), datasetIdPrefixToTruncate);
            String attrName = (attributePrefix.isEmpty() ? attributePrefix : attributePrefix + "_") + encodedAttrName;
            String attrType = attribute.getAttrType();
            JsonElement attrValue = new JsonPrimitive(attribute.getAttrValue());
            aggregation.put(attrName, attrValue);
            aggregation.put(attrName + NGSIConstants.AUTOGENERATED_ATTR_TYPE, new JsonPrimitive(attrType));
            if (attribute.isHasSubAttrs()) {
                aggregateAttributeValues(attrName, attribute.getSubAttrs(), datasetIdPrefixToTruncate);
            }
        }
    }

    private String encodeAttributeName(String attributeName, String datasetId, String datasetIdPrefixToTruncate) {
        // For too long dataset ids, truncate to 32 (not perfect, nor totally bulletproof)
        String datasetIdEncodedValue =
                (!datasetId.isEmpty() ?
                        "_" + NGSICharsets.encodeCKAN(NGSICharsets.truncateToSize(datasetId.replaceFirst(datasetIdPrefixToTruncate, ""), 32)) :
                        ""
                );
        String encodedName = NGSICharsets.encodeCKAN(attributeName) + datasetIdEncodedValue;
        return encodedName.toLowerCase();
    }
}
